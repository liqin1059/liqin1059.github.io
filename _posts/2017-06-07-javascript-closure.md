---
layout: post
title: javascript闭包的作用
date: 2017-06-07 13:31:30
categories: javascript
tags: []
---
在javascript
闭包`closure`的形成与变量的作用域以及变量的生成周期密切相关。
### 变量的作用域
- 变量的有效范围。
- 如果一个函数中声明一个变量的时候没有带var ,那么这个变量就会变成全局变量，这是一种容易造成命名冲突的方法。
- 如果这个函数带有var,这个变量即局部变量，只有在该函数内部才能访问得到，函数外部是无法访问的。
在函数中搜索一个变量的时候，如果函数内部没有声明这个变量，那么此次搜索过程会随着代码执行环境创建的作用域链往外层逐层搜索，一直搜索到全局对象为止。变量的搜索是**从内到外**的。
### 变量的生存周期
- 全局变量的生存周期是永久的
- 局部变量在退出这函数时即失去了它的价值，随着函数调用的结束而被销毁

```
var func = function(){
	var a= 1;	//退出即被销毁
	alert(a);
}
```

>然而：

```
var func = function(){
	var a= 1; 
	return function(){
		a++;
		alert(a);
	}
};
var f = func();
f();	//输出2
f();	//输出3
f();	//输出4
f();	//输出5
```

- 在上面这个函数中，退出函数局部变量a却没有消失，是因为`var f =func()`时，返回了一个匿名函数的引用，它可以访问到func()被调用时产生的环境，
而局部变量a一直处在这个环境中。局部变量所在环境还能被外界环境访问到，这个局部变量有了不被销毁的理由。在这里产生了一个闭包结构，局部变量的生命看起来被延续了。
利用闭包可以完成许多工作，比如页面上有5个div我们想要给每个div绑定onclick事件，按照索引顺序，点击第一个div时弹出1，依次弹出1,2,3...代码如下：

```
var divs = document.getElementsByTagName('div');
for(var i = 0 ,divLength = divs.length;i++ ){
		divs[i].onlick = function(){
		alert(i);
	}
};

```
>这时会发现无论点击哪个div都会弹出5,节点onlick事件是被异步触发的，当事件被触发的时候，for循环早已结束，所以在div的onlick事件顺着作用域链从内到外查找变量i时，查找到的值总是5.

>解决方法是在闭包的帮助下，把每次循环的i值都封闭起来。这样事件函数查找的时候就会找到被封闭在闭包环境中的i，即1,2,3,4,5

```
for(var i = 0 ,divLength = divs.length;i++ ){
	;(function(i){
        divs[i].onlick = function(){
		alert(i);
	})(i);
}
```
### 闭包的作用
- 封装变量
- 延续局部变量的寿命

